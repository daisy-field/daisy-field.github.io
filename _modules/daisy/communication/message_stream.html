

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>daisy.communication.message_stream &mdash; DAISY 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../../_static/favicon2.ico"/>
    <link rel="canonical" href="https://daisy-field.github.io/_modules/daisy/communication/message_stream.html" />
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DAISY
              <img src="../../../_static/favicon2.ico" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../general.overview.html">What is DAISY?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../general.background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../general.datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../general.dashboard.html">Dashboard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.communication.html">Communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.data_sources.html">Datasources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.evaluation.html">Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.federated_ids_components.html">Federated IDS Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.federated_learning.html">Federated Learning</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.scripts.data_collection.html">Data Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.scripts.demo_components.html">Demo Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daisy.scripts.generic_fids_components.html">Demo Servers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DAISY</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">daisy.communication.message_stream</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for daisy.communication.message_stream</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2024-2025 DAI-Labor and others</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="sd">&quot;&quot;&quot;An efficient, persistent, and stateless communications stream between two</span>
<span class="sd">endpoints over BSD sockets. Supports SSL (soon) and LZ4 compression.</span>

<span class="sd">Author: Fabian Hofmann</span>
<span class="sd">Modified: 16.10.24</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">queue</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">select</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">socket</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Self</span>

<span class="c1"># noinspection PyUnresolvedReferences</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lz4.frame</span><span class="w"> </span><span class="kn">import</span> <span class="n">compress</span><span class="p">,</span> <span class="n">decompress</span>


<div class="viewcode-block" id="EndpointSocket">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointSocket">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EndpointSocket</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A bundle of up to two sockets, that is used to communicate with another</span>
<span class="sd">    endpoint over a persistent TCP connection in synchronous manner. Supports</span>
<span class="sd">    authentication and encryption over SSL, and stream compression using LZ4.</span>
<span class="sd">    Thread-safe for both access to the same endpoint socket and using multiple</span>
<span class="sd">    threads using endpoint sockets set to the same address (this is organized through</span>
<span class="sd">    an array of class variables, see below for more info).</span>

<span class="sd">    :cvar _listen_socks: Active listen sockets, along with a respective lock to access</span>
<span class="sd">    each safely.</span>
<span class="sd">    :cvar _acc_r_socks: Pending registered connection cache for each listen socket.</span>
<span class="sd">    :cvar _acc_p_socks: Pending unregistered connection queue for each listen socket.</span>
<span class="sd">    :cvar _reg_r_addrs: Registered remote addresses.</span>
<span class="sd">    :cvar _addr_map: Mapping between registered remote addresses and their aliases.</span>
<span class="sd">    :cvar _act_l_counts: Active thread counter for each listen socket. Socket closes</span>
<span class="sd">    if counter reaches zero.</span>
<span class="sd">    :cvar _lock: General purpose lock to ensure safe access to class variables.</span>
<span class="sd">    :cvar _cls_logger: General purpose logger for class methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_listen_socks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_acc_r_socks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">],</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_acc_p_socks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_reg_r_addrs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">_addr_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_act_l_counts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">_cls_logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;EndpointSocketCLS&quot;</span><span class="p">)</span>

    <span class="n">_logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span>

    <span class="n">_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">_remote_addr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="n">_acceptor</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="n">_send_b_size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_recv_b_size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_sock</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">]</span>
    <span class="n">_sock_lock</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span>

    <span class="n">_keep_alive</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="n">_conn_rdy</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span>
    <span class="n">_opened</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">acceptor</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">send_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">recv_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">keep_alive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new endpoint socket. Implementation note: A pre-defined remote</span>
<span class="sd">        address is not a guarantee that this endpoint will successfully be allowed to</span>
<span class="sd">        initialize for this remote address --- for example if another endpoint sock</span>
<span class="sd">        with the same remote address (be it generic or pre-defined) has already been</span>
<span class="sd">        registered, then the current one will throw an error.</span>

<span class="sd">        :param name: Name of endpoint for logging purposes.</span>
<span class="sd">        :param addr: Address of endpoint. Mandatory in acceptor mode (acceptor set to</span>
<span class="sd">        True), for initiators this fixes the address the endpoint is bound to.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to be connected to. Mandatory in</span>
<span class="sd">        initiator mode (acceptor set to false), for acceptors this fixes the remote</span>
<span class="sd">        endpoint that is allowed to be connected to this endpoint.</span>
<span class="sd">        :param acceptor: Determines whether the endpoint accepts or initiates</span>
<span class="sd">        connections to/from other endpoints.</span>
<span class="sd">        :param send_b_size: Underlying send buffer size of socket.</span>
<span class="sd">        :param recv_b_size: Underlying receive buffer size of socket.</span>
<span class="sd">        :param keep_alive: Determines whether to attempt re-connects after the remote</span>
<span class="sd">        endpoint has terminated the connection.</span>
<span class="sd">        :raises ValueError: If the remote address is already taken for the acceptor,</span>
<span class="sd">        or if the address/remote address is not provided for acceptor/initiator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;-Socket&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initializing endpoint socket </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="k">if</span> <span class="n">addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span> <span class="o">=</span> <span class="n">remote_addr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span> <span class="o">=</span> <span class="n">acceptor</span>
        <span class="k">if</span> <span class="n">acceptor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">addr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Accepting endpoint socket requires an address!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reg_remote</span><span class="p">(</span><span class="n">remote_addr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fix_rp_acc_socks</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">remote_addr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Initiating endpoint socket requires a remote address!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_send_b_size</span> <span class="o">=</span> <span class="n">send_b_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recv_b_size</span> <span class="o">=</span> <span class="n">recv_b_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_keep_alive</span> <span class="o">=</span> <span class="n">keep_alive</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_conn_rdy</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Endpoint socket </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2"> initialized.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="EndpointSocket.open">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointSocket.open">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens the endpoint socket along with its underlying socket(s) and its</span>
<span class="sd">        connection to a/the remote endpoint socket. Blocking until the connection is</span>
<span class="sd">        established.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Opening endpoint socket...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open_l_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conn_rdy</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Endpoint socket opened.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EndpointSocket.close">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointSocket.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutdown</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Closes the endpoint socket, cleaning up any underlying datastructures if</span>
<span class="sd">        acceptor. If already closed, allows the cleanup of just the datastructures</span>
<span class="sd">        incase a shutdown is requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span>
            <span class="ow">and</span> <span class="n">shutdown</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unreg_remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Closing endpoint socket...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="p">:</span>
            <span class="n">_close_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">shutdown</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_unreg_remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_close_l_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Endpoint socket closed.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EndpointSocket.send">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointSocket.send">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends the given bytes of a single object over the connection, performing</span>
<span class="sd">        simple marshalling (size is sent first, then the bytes of the object).</span>
<span class="sd">        Fault-tolerant for breakdowns and resets in the connection. Blocking.</span>

<span class="sd">        :param p_data: Bytes to send.</span>
<span class="sd">        :raises RuntimeError: If connection has been terminated by remote endpoint</span>
<span class="sd">        and keep-alive is disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_check_w_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">):</span>
                    <span class="n">_send_payload</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="n">p_data</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keep_alive</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">is</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;while trying to send data. Retrying...&quot;</span>
                <span class="p">)</span>
                <span class="c1"># release() of sock_lock is done in connect()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connect</span><span class="p">()</span></div>


<div class="viewcode-block" id="EndpointSocket.recv">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointSocket.recv">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">recv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Receives the bytes of a single object sent over the connection, performing</span>
<span class="sd">        simple marshalling (size is received first, then the bytes of the object).</span>
<span class="sd">        Fault-tolerant for breakdowns and resets in the connection. Blocking in</span>
<span class="sd">        default-mode if timeout not set.</span>

<span class="sd">        :param timeout: Timeout (seconds) to receive an object to return.</span>
<span class="sd">        :return: Received bytes or None of end point socket has been closed.</span>
<span class="sd">        :raises TimeoutError: If timeout set and triggered.</span>
<span class="sd">        :raises RuntimeError: If connection has been terminated by remote endpoint</span>
<span class="sd">        and keep-alive is disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_check_r_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">):</span>
                    <span class="n">p_data</span> <span class="o">=</span> <span class="n">_recv_payload</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">p_data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">is</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keep_alive</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">is</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;while trying to receive data. Retrying...&quot;</span>
                <span class="p">)</span>
                <span class="c1"># release() of sock_lock is done in connect()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connect</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="EndpointSocket.poll">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointSocket.poll">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">poll</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Polls the state of various state and addresses of the endpoint socket:</span>
<span class="sd">            * 0,0: Existence of socket (true if connected).</span>
<span class="sd">            * 0,1: Whether there is something to read on the underlying socket.</span>
<span class="sd">            * 0,2: Whether one is able to write on the underlying socket.</span>
<span class="sd">            + 1,0: Address of endpoint socket, else None</span>
<span class="sd">            + 1,1: Address of remote endpoint socket, else None.</span>
<span class="sd">        Note this does not necessarily guarantee that the underlying socket is</span>
<span class="sd">        actually connected and available for reading/writing; e.g. the connection</span>
<span class="sd">        could have broken down since then and is currently being re-established.</span>

<span class="sd">        :param lazy: Whether to lazily skip the actual state of the underlying socket</span>
<span class="sd">        and just check for connectivity.</span>
<span class="sd">        :return: Tuple of boolean states (connectivity, readability, writability) and</span>
<span class="sd">        address-pair of endpoint socket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lazy</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="p">:</span>
                <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="n">states</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(Re-)Establishes a connection to a/the remote endpoint socket,</span>
<span class="sd">        first performing any necessary cleanup of the underlying socket,</span>
<span class="sd">        before opening it again and trying to connect/accept a remote endpoint</span>
<span class="sd">        socket. Fault-tolerant for breakdowns and resets in the connection. Blocking.</span>

<span class="sd">        Note if called multiple times concurrently, only one call is executed,</span>
<span class="sd">        the other callers release any locks they are holding and wait until the first</span>
<span class="sd">        caller has established the connection and set the semaphore accordingly.</span>

<span class="sd">        Also note the longer an endpoint socket attempts to re-establish the</span>
<span class="sd">        connection, the longer it will wait inbetween attempts. This is done to</span>
<span class="sd">        prevent busy waiting of endpoint sockets occupying the same listening socket,</span>
<span class="sd">        the exception being initial attempts to establish the connection.</span>

<span class="sd">        :param initial: Whether this is the first time the connection is established.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn_rdy</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conn_rdy</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conn_rdy</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Trying to (re-)establish connection &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Connection </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="si">}</span><span class="s2"> (re-)established.&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">e_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">) while trying to (re-)establish &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;connection </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="si">}</span><span class="s2">. Retrying...&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">e_msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">e_msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                <span class="n">sleep</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
                <span class="c1"># initial attempts of an endpoint socket never do binary backoff (+0)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">initial</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conn_rdy</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(Re-)Establishes a connection to a/the remote endpoint socket,</span>
<span class="sd">        first performing any necessary cleanup of the underlying socket,</span>
<span class="sd">        before attempting to open it and trying to connect/accept a remote endpoint</span>
<span class="sd">        socket. In case it fails, raises the respective error. Idempotent,</span>
<span class="sd">        may be called multiple times until connection is established.</span>

<span class="sd">        :raises Error: Various errors when failing to establish a connection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_close_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span><span class="p">:</span>
            <span class="n">remote_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="n">remote_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_a_socket</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span> <span class="o">=</span> <span class="n">remote_addr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_c_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_addr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_SNDBUF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_b_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_RCVBUF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_b_size</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reg_remote</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers a remote address into the class datastructures, notifying other</span>
<span class="sd">        endpoints of its existence. Tries to both resolve the address and finds its</span>
<span class="sd">        fully qualified hostname to reserve all its aliases. If only a single alias</span>
<span class="sd">        is already registered, aborts the whole registration process and registers</span>
<span class="sd">        none of the aliases.</span>

<span class="sd">        :param remote_addr: Remote address to register.</span>
<span class="sd">        :raises ValueError: If remote address is already registered (possibly by</span>
<span class="sd">        another caller).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering remote address (</span><span class="si">{</span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>
        <span class="n">addr_mapping</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span>
            <span class="o">*</span><span class="n">remote_addr</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>
        <span class="p">):</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">_convert_addr_to_name</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="n">addr_mapping</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Registering aliases of remote address (</span><span class="si">{</span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">addr_mapping</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_addr_map</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Remote address (</span><span class="si">{</span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">) is already registered!&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addr_mapping</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_reg_r_addrs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Remote address (</span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">) (resolved from </span><span class="si">{</span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">)&quot;</span>
                        <span class="s2">&quot; is already registered!&quot;</span>
                    <span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">_addr_map</span><span class="p">[</span><span class="n">remote_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr_mapping</span>
            <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addr_mapping</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_reg_r_addrs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Remote address (</span><span class="si">{</span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">) registered.&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_rp_acc_socks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;After a remote address has been registered, cycles the waiting connections</span>
<span class="sd">        of that remote address to the registered socket dictionary from the pending</span>
<span class="sd">        socket queue. Necessary, as new endpoint sockets may be created while the</span>
<span class="sd">        listening socket is already opened and connections are already getting accepted.</span>

<span class="sd">        Note this method merely helps in speeding up the sorting of connections to</span>
<span class="sd">        the correct endpoint socket and operates in best-effort manner, as the whole</span>
<span class="sd">        method is not considered a critical section, i.e. during the cycling of</span>
<span class="sd">        connections, the registered connection could be accepted by another thread</span>
<span class="sd">        and be put into the pending connection cache, where it will be dequeued by</span>
<span class="sd">        another thread --- which will result in a ValueError since the remote peer is</span>
<span class="sd">        obviously registered. However, no much of an issue, as the error handling is</span>
<span class="sd">        done in the background during the handling of existing connections.</span>

<span class="sd">        :param addr: Address of endpoint.</span>
<span class="sd">        :param remote_addr: Remote address that was registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Fixing registered and pending connection caches for address pair &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="p">)</span>
        <span class="n">l_addr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_l_socket</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="n">addr_mapping</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_addr_map</span><span class="p">[</span><span class="n">remote_addr</span><span class="p">]</span>
            <span class="n">acc_p_socks</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_p_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>
            <span class="n">acc_r_socks</span><span class="p">,</span> <span class="n">acc_r_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_r_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>

        <span class="n">p_socks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span> <span class="o">=</span> <span class="n">acc_p_socks</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
                <span class="k">with</span> <span class="n">acc_r_lock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a_addr</span> <span class="ow">in</span> <span class="n">addr_mapping</span><span class="p">:</span>
                        <span class="n">_close_socket</span><span class="p">(</span><span class="n">acc_r_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a_addr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                        <span class="n">acc_r_socks</span><span class="p">[</span><span class="n">a_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_sock</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p_socks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span> <span class="ow">in</span> <span class="n">p_socks</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">acc_p_socks</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
                <span class="n">_close_socket</span><span class="p">(</span><span class="n">a_sock</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Registered and pending connection caches for &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;address pair </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2"> fixed.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_unreg_remote</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unregisters a remote address from the class datastructures. Uses the</span>
<span class="sd">        existing mappings from the original resolution. Also cycles any pending</span>
<span class="sd">        connections of that remote address from the registered socket dictionary to</span>
<span class="sd">        the pending socket queue so the connection may be accepted by any other</span>
<span class="sd">        (generic or pre-defined) endpoint socket listening on the same address.</span>

<span class="sd">        :param remote_addr: Remote address that was registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unregistering remote address pair </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="p">)</span>
        <span class="n">l_addr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_l_socket</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="n">addr_mapping</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_addr_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">remote_addr</span><span class="p">)</span>
            <span class="n">acc_p_socks</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_p_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>
            <span class="n">acc_r_socks</span><span class="p">,</span> <span class="n">acc_r_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_r_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">a_addr</span> <span class="ow">in</span> <span class="n">addr_mapping</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_reg_r_addrs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">a_addr</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">acc_r_lock</span><span class="p">:</span>
                <span class="n">a_sock</span> <span class="o">=</span> <span class="n">acc_r_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a_addr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">acc_p_socks</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
                    <span class="n">_close_socket</span><span class="p">(</span><span class="n">a_sock</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Remote address pair </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2"> unregistered.&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_open_l_socket</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens the socket listening to a given address, iff there are no further</span>
<span class="sd">        endpoint sockets listening on the same socket as well.</span>

<span class="sd">        :param addr: Address of listen socket to open.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_get_l_socket</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">new_endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_l_socket</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">new_endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the socket listening to a given address. If this socket does not</span>
<span class="sd">        exist already, creates it and with it all accompanying datastructures.</span>
<span class="sd">        Supports address resolution.</span>

<span class="sd">        :param addr: Address of listen socket.</span>
<span class="sd">        :return: A tupel consisting of the address, the socket, and a lock to be used</span>
<span class="sd">        for accessing the socket.</span>
<span class="sd">        :raises RuntimeError: If none of the addresses/aliases succeed to create a</span>
<span class="sd">        working socket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to retrieve listening socket for </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
            <span class="n">s_af</span><span class="p">,</span> <span class="n">s_t</span><span class="p">,</span> <span class="n">s_p</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">s_addr</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">l_addr</span> <span class="o">=</span> <span class="n">_convert_addr_to_name</span><span class="p">(</span><span class="n">s_addr</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
                <span class="n">l_sock</span><span class="p">,</span> <span class="n">l_sock_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_listen_socks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l_addr</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">l_sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">l_sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">s_af</span><span class="p">,</span> <span class="n">s_t</span><span class="p">,</span> <span class="n">s_p</span><span class="p">)</span>
                        <span class="n">l_sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">l_sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">s_addr</span><span class="p">)</span>
                        <span class="n">l_sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">65535</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                        <span class="n">_close_socket</span><span class="p">(</span><span class="n">l_sock</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">l_sock_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_listen_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_sock</span><span class="p">,</span> <span class="n">l_sock_lock</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_r_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_p_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_endpoint</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_act_l_counts</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_act_l_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Listening socket </span><span class="si">{</span><span class="n">l_addr</span><span class="p">,</span><span class="w"> </span><span class="n">l_sock</span><span class="p">,</span><span class="w"> </span><span class="n">l_sock_lock</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2"> retrieved&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">l_addr</span><span class="p">,</span> <span class="n">l_sock</span><span class="p">,</span> <span class="n">l_sock_lock</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not open listen socket for </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_close_l_socket</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Closes the socket listening to a given address, iff there are no further</span>
<span class="sd">        endpoint sockets listening on the same socket as well.</span>

<span class="sd">        :param addr: Address of listen socket to close.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Performing cleanup for listening socket for </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="n">l_addr</span><span class="p">,</span> <span class="n">l_sock</span><span class="p">,</span> <span class="n">l_sock_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_l_socket</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">,</span> <span class="n">l_sock_lock</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_act_l_counts</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_act_l_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_act_l_counts</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_listen_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">l_addr</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_r_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">l_addr</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_p_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">l_addr</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_act_l_counts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">l_addr</span><span class="p">)</span>
            <span class="n">_close_socket</span><span class="p">(</span><span class="n">l_sock</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listening socket for </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2"> closed.&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_a_socket</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets an accepted connection socket assigned to a socket of a given</span>
<span class="sd">        address. The connection socket can either be connected to an arbitrary</span>
<span class="sd">        endpoint or to a pre-defined remote peer (remote address). If remote address</span>
<span class="sd">        is not pre-defined, also registers the remote peer&#39;s address. As the</span>
<span class="sd">        underlying datastructures are shared between all endpoint sockets (of a</span>
<span class="sd">        process), a connection socket can either be retrieved from them or directly</span>
<span class="sd">        from the listen socket.</span>

<span class="sd">        :param addr: Address of listen socket.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to be connected to.</span>
<span class="sd">        :return: Tuple of the connection socket and the address of the remote peer.</span>
<span class="sd">        :raises RuntimeError: If none of the addresses/aliases of the listen socket</span>
<span class="sd">        succeed to get a working socket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Trying to retrieve accept socket for </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="p">)</span>
        <span class="n">l_addr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_l_socket</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

        <span class="c1"># Check the active connection cache first, as another Endpoint</span>
        <span class="c1"># might have accepted this one&#39;s registered connection already.</span>
        <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a_sock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_r_acc_sock</span><span class="p">(</span><span class="n">l_addr</span><span class="p">,</span> <span class="n">remote_addr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Accept socket </span><span class="si">{</span><span class="n">l_addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;from registered connection cache retrieved.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">remote_addr</span>

        <span class="c1"># Check the pending connection queue, if this thread does not care</span>
        <span class="c1"># about the address of the remote peer. If connection, registers it.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_p_acc_sock</span><span class="p">(</span><span class="n">l_addr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_reg_remote</span><span class="p">(</span><span class="n">a_addr</span><span class="p">)</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Accept socket for </span><span class="si">{</span><span class="n">l_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;from pending connection queue retrieved.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">_close_socket</span><span class="p">(</span><span class="n">a_sock</span><span class="p">)</span>

        <span class="c1"># Check the OS connection backlog for pending connections</span>
        <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_n_acc_sock</span><span class="p">(</span><span class="n">l_addr</span><span class="p">,</span> <span class="n">remote_addr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_reg_remote</span><span class="p">(</span><span class="n">a_addr</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">_close_socket</span><span class="p">(</span><span class="n">a_sock</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">remote_addr</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_r_acc_sock</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">l_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves and returns a registered (accepted) connection socket assigned</span>
<span class="sd">        to a socket of a given address, if it exists in the (shared) active</span>
<span class="sd">        registered connection cache.</span>

<span class="sd">        :param l_addr: Address of listen socket.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to be connected to.</span>
<span class="sd">        :return: Tuple of the registered connection socket and the address of the</span>
<span class="sd">        remote peer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Trying to retrieve accept socket for </span><span class="si">{</span><span class="n">l_addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;from registered connection cache...&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="n">acc_r_socks</span><span class="p">,</span> <span class="n">acc_r_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_r_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span>
            <span class="o">*</span><span class="n">remote_addr</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>
        <span class="p">):</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">_convert_addr_to_name</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">acc_r_lock</span><span class="p">:</span>
                <span class="n">a_sock</span> <span class="o">=</span> <span class="n">acc_r_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a_sock</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_p_acc_sock</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">l_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves and returns a pending, not registered (accepted) connection</span>
<span class="sd">        socket assigned to a socket of a given address, if there is one in the</span>
<span class="sd">        pending connection queue.</span>

<span class="sd">        :param l_addr: Address of listen socket.</span>
<span class="sd">        :return: Tuple of a connection socket and the address of the remote peer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Trying to retrieve accept socket for </span><span class="si">{</span><span class="n">l_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;from pending connection queue...&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="n">acc_p_socks</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_p_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acc_p_socks</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_n_acc_sock</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">l_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves, accepts, and returns a pending connection socket from the OS</span>
<span class="sd">        connection backlog if there is one. The connection socket can either be</span>
<span class="sd">        connected to an arbitrary endpoint or to a pre-defined remote peer (remote</span>
<span class="sd">        address). If the remote address is not pre-defined, returns any connection</span>
<span class="sd">        socket that does not belong to another (registered) endpoint socket,</span>
<span class="sd">        otherwise stores them in the shared data structures. The same is done the</span>
<span class="sd">        other way around with the pending connection queue.</span>

<span class="sd">        :param l_addr: Address of listen socket.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to be connected to.</span>
<span class="sd">        :return: Tuple of a connection socket and the address of the remote peer.</span>
<span class="sd">        :raises RuntimeError: If there are no new connections are in the OS</span>
<span class="sd">        connection backlog.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to accept socket for </span><span class="si">{</span><span class="n">l_addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="n">l_sock</span><span class="p">,</span> <span class="n">l_sock_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_listen_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>
            <span class="n">acc_r_socks</span><span class="p">,</span> <span class="n">acc_r_lock</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_r_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>
            <span class="n">acc_p_socks</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_acc_p_socks</span><span class="p">[</span><span class="n">l_addr</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">l_sock_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">l_sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not open connection socket for </span><span class="si">{</span><span class="n">l_addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">!&quot;</span>
                <span class="p">)</span>
            <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span> <span class="o">=</span> <span class="n">l_sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">a_addr</span> <span class="o">=</span> <span class="n">_convert_addr_to_name</span><span class="p">(</span><span class="n">a_addr</span><span class="p">)</span>

        <span class="c1"># 1. If it is the predefined remote peer, uses it for Endpoint.</span>
        <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">r_addr</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span>
                <span class="o">*</span><span class="n">remote_addr</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>
            <span class="p">):</span>
                <span class="n">r_addr</span> <span class="o">=</span> <span class="n">_convert_addr_to_name</span><span class="p">(</span><span class="n">r_addr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r_addr</span> <span class="o">==</span> <span class="n">a_addr</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span>

        <span class="c1"># 2. If it is an already registered remote peer, puts it into cache.</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_lock</span><span class="p">,</span> <span class="n">acc_r_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a_addr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_reg_r_addrs</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Storing accept socket </span><span class="si">{</span><span class="n">a_sock</span><span class="p">,</span><span class="w"> </span><span class="n">a_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;into registered connection cache...&quot;</span>
                <span class="p">)</span>
                <span class="n">_close_socket</span><span class="p">(</span><span class="n">acc_r_socks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a_addr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">acc_r_socks</span><span class="p">[</span><span class="n">a_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_sock</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># 3. If the predefined remote peer is undefined, uses it for Endpoint.</span>
        <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span>

        <span class="c1"># Any other connection is stored in the pending connection queue.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Storing accept socket </span><span class="si">{</span><span class="n">a_sock</span><span class="p">,</span><span class="w"> </span><span class="n">a_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;into pending connection queue...&quot;</span>
            <span class="p">)</span>
            <span class="n">acc_p_socks</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">a_sock</span><span class="p">,</span> <span class="n">a_addr</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
            <span class="n">_close_socket</span><span class="p">(</span><span class="n">a_sock</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_c_socket</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates and returns a connection socket to a given remote address,</span>
<span class="sd">        that might be bound to a specific address, if given. Non-Blocking (with</span>
<span class="sd">        timeout) during connection attempts.</span>

<span class="sd">        :param addr: Local address to bind endpoint to. If none provided, OS chooses</span>
<span class="sd">        an address.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to be connected to.</span>
<span class="sd">        :return: Tuple of the connection socket and the address of the socket.</span>
<span class="sd">        :raises RuntimeError: If no connection can be established.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cls_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Trying to open connection socket for </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
            <span class="n">s_af</span><span class="p">,</span> <span class="n">s_t</span><span class="p">,</span> <span class="n">s_p</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">s_addr</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">r_res_list</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span>
                <span class="o">*</span><span class="n">remote_addr</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">s_af</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">s_t</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">s_p</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">r_res</span> <span class="ow">in</span> <span class="n">r_res_list</span><span class="p">:</span>
                <span class="n">r_af</span><span class="p">,</span> <span class="n">r_t</span><span class="p">,</span> <span class="n">r_p</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">r_addr</span> <span class="o">=</span> <span class="n">r_res</span>
                <span class="n">sock</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">r_af</span><span class="p">,</span> <span class="n">r_t</span><span class="p">,</span> <span class="n">r_p</span><span class="p">)</span>
                    <span class="n">sock</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">s_addr</span><span class="p">)</span>
                    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">r_addr</span><span class="p">)</span>
                    <span class="n">sock</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="n">_close_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">return</span> <span class="n">sock</span><span class="p">,</span> <span class="n">_convert_addr_to_name</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">getsockname</span><span class="p">())</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not open connection socket for </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="StreamEndpoint">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StreamEndpoint</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;One of a pair of endpoints that is able to communicate with one another over a</span>
<span class="sd">    persistent stateless stream over BSD sockets. Allows the transmission of generic</span>
<span class="sd">    objects in both synchronous and asynchronous fashion. Supports SSL and LZ4</span>
<span class="sd">    compression for the stream. Thread-safe for both access to the same endpoint and</span>
<span class="sd">    using multiple threads using endpoints set to the same address.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span>

    <span class="n">_endpoint_socket</span><span class="p">:</span> <span class="n">EndpointSocket</span>
    <span class="n">_marshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">object</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">]</span>
    <span class="n">_unmarshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">bytes</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span>

    <span class="n">_multithreading</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_sender</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span>
    <span class="n">_receiver</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span>
    <span class="n">_send_buffer</span><span class="p">:</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span>
    <span class="n">_recv_buffer</span><span class="p">:</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span>

    <span class="n">_started</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_ready</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span>
    <span class="n">_stopped</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span>
    <span class="n">_shutdown</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;StreamEndpoint&quot;</span><span class="p">,</span>
        <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">acceptor</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">send_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">recv_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">marshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">object</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
        <span class="n">unmarshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">bytes</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">,</span>
        <span class="n">multithreading</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
        <span class="n">keep_alive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new endpoint.</span>

<span class="sd">        :param name: Name of endpoint for logging purposes.</span>
<span class="sd">        :param addr: Address of endpoint.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to be connected to. Optional in</span>
<span class="sd">        acceptor mode.</span>
<span class="sd">        :param acceptor: Determines whether the endpoint accepts or initiates</span>
<span class="sd">        connections to/from other endpoints.</span>
<span class="sd">        :param send_b_size: Underlying send buffer size of socket.</span>
<span class="sd">        :param recv_b_size: Underlying receive buffer size of socket.</span>
<span class="sd">        :param compression: Enables lz4 stream compression for bandwidth optimization.</span>
<span class="sd">        :param marshal_f: Marshal function to serialize objects to send into bytes.</span>
<span class="sd">        :param unmarshal_f: Unmarshal function to deserialize received bytes into</span>
<span class="sd">        objects.</span>
<span class="sd">        :param multithreading: Enables transparent multithreading (i.e. asynchronous</span>
<span class="sd">        object processing) for speedup.</span>
<span class="sd">        :param buffer_size: Size of shared buffer in multithreading mode.</span>
<span class="sd">        :param keep_alive: Determines whether to attempt re-connects after the remote</span>
<span class="sd">        endpoint has terminated the connection or to stop the endpoint. Such</span>
<span class="sd">        connection endings will also result in RuntimeErrors in synchronous mode</span>
<span class="sd">        (during send()/receive()) and the automatic exiting of endpoint</span>
<span class="sd">        sender/receiver loops if multithreading is set. Note that the actual shut</span>
<span class="sd">        down of the endpoint may still be called separately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initializing endpoint </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span> <span class="o">=</span> <span class="n">EndpointSocket</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span>
            <span class="n">remote_addr</span><span class="o">=</span><span class="n">remote_addr</span><span class="p">,</span>
            <span class="n">acceptor</span><span class="o">=</span><span class="n">acceptor</span><span class="p">,</span>
            <span class="n">send_b_size</span><span class="o">=</span><span class="n">send_b_size</span><span class="p">,</span>
            <span class="n">recv_b_size</span><span class="o">=</span><span class="n">recv_b_size</span><span class="p">,</span>
            <span class="n">keep_alive</span><span class="o">=</span><span class="n">keep_alive</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">compression</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_marshal_f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">compress</span><span class="p">(</span><span class="n">marshal_f</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unmarshal_f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">unmarshal_f</span><span class="p">(</span><span class="n">decompress</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_marshal_f</span> <span class="o">=</span> <span class="n">marshal_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unmarshal_f</span> <span class="o">=</span> <span class="n">unmarshal_f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span> <span class="o">=</span> <span class="n">multithreading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stopped</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Endpoint </span><span class="si">{</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">remote_addr</span><span class="si">}</span><span class="s2"> initialized.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="StreamEndpoint.start">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the endpoint, either in threaded fashion or as part of the main</span>
<span class="sd">        thread. By doing so, the two endpoints are connected and the datastream is</span>
<span class="sd">        opened. This method is blocking until a connection is established by default</span>
<span class="sd">        if multithreading is not enabled or the respective flag is not set. If either</span>
<span class="sd">        is the case, the caller can check the readiness of the connection via the</span>
<span class="sd">        returned event object. Note that in multithreading mode, objects can already</span>
<span class="sd">        be sent/received, however they will only be stored in internal buffers until</span>
<span class="sd">        the establishing of connection (sets the semaphore accordingly to allow async</span>
<span class="sd">        sender and receiver to proceed).</span>

<span class="sd">        :param blocking: Whether to wait for a connection to be established in</span>
<span class="sd">        non-multithreading (sync) mode.</span>
<span class="sd">        :return: Event object to check endpoint&#39;s readiness to send/receive. Always</span>
<span class="sd">        true if start() was called blocking.</span>
<span class="sd">        :raises RuntimeError: If endpoint has already been started or shut down.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">start_ep_socket</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting endpoint...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint has already been shut down!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint has already been started!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stopped</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting endpoint socket starter thread...&quot;</span><span class="p">)</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">start_ep_socket</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_ep_socket</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Multithreading detected, starting endpoint sender/receiver threads...&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sender</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_sender</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_receiver</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_receiver</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sender</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_receiver</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Endpoint started.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span></div>


<div class="viewcode-block" id="StreamEndpoint.stop">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.stop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutdown</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stops the endpoint and closes the stream, cleaning up underlying</span>
<span class="sd">        datastructures. If multithreading is enabled, waits for both endpoint threads</span>
<span class="sd">        to stop before finishing. Note this does not guarantee the sending and</span>
<span class="sd">        receiving of all objects still pending --- they may still be in internal</span>
<span class="sd">        buffers and will be processed if the endpoint is opened again,</span>
<span class="sd">        or get discarded by the underlying socket. This method is blocking until the</span>
<span class="sd">        endpoint is fully closed / shutdown if multithreading is not enabled or the</span>
<span class="sd">        respective flag is not set. If either is the case, the caller can check the</span>
<span class="sd">        progress via the returned event object.</span>

<span class="sd">        Also note if the endpoint has not been started or has already been closed,</span>
<span class="sd">        a set shutdown flag still results in the full cleanup of the underlying</span>
<span class="sd">        datastructures.</span>

<span class="sd">        :param shutdown: If set, also cleans up underlying datastructures of the</span>
<span class="sd">        socket communication.</span>
<span class="sd">        :param timeout: Allows the sender thread to process remaining messages until</span>
<span class="sd">        timeout.</span>
<span class="sd">        :param blocking: Whether to wait for the endpoint to be closed in</span>
<span class="sd">        non-multithreading (sync) mode.</span>
<span class="sd">        :return: Event object to check whether endpoint is closed. Always true if</span>
<span class="sd">        stop() was called blocking.</span>
<span class="sd">        :raises RuntimeError: If endpoint has not been started or already shut down.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">stop_ep_sock</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="ow">and</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">:</span>
                    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">shutdown</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown</span> <span class="o">=</span> <span class="n">shutdown</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Multithreading detected, waiting for &quot;</span>
                    <span class="s2">&quot;endpoint sender/receiver threads to stop...&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sender</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_receiver</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopped</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Stopping endpoint...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown</span> <span class="ow">and</span> <span class="n">shutdown</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Shutdown on closed endpoint detected, cleaning up endpoint...&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">shutdown</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Endpoint has not been started or already shut down!&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting endpoint socket stopping thread...&quot;</span><span class="p">)</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">stop_ep_sock</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop_ep_sock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Endpoint stopped.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopped</span></div>


<div class="viewcode-block" id="StreamEndpoint.send">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.send">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic send function that sends any object as a pickle over the</span>
<span class="sd">        persistent datastream. If multithreading is enabled, this function is</span>
<span class="sd">        non-blocking.</span>

<span class="sd">        :param obj: Object to send.</span>
<span class="sd">        :raises RuntimeError: If endpoint has not been started or has been terminated</span>
<span class="sd">        by the remote counterpart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sending object...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint has not been started!&quot;</span><span class="p">)</span>

        <span class="n">p_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marshal_f</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Multithreading detected, putting object &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;into buffer (size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s2">)...&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pickled object sent of size </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="StreamEndpoint.receive">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.receive">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic receive function that receives data as a pickle over the</span>
<span class="sd">        persistent datastream, unpickles it into the respective object and returns</span>
<span class="sd">        it. Blocking in default-mode if timeout not set. Also supports receiving</span>
<span class="sd">        objects past the closing of the endpoint, if multithreading is enabled and</span>
<span class="sd">        the objects have already been received nad stored in the receive buffer.</span>

<span class="sd">        :param timeout: Timeout (seconds) to receive an object to return.</span>
<span class="sd">        :return: Received object.</span>
<span class="sd">        :raises RuntimeError: If endpoint has not been started or has been terminated</span>
<span class="sd">        by the remote counterpart, and there is nothing to receive asynchronously</span>
<span class="sd">        (multithreading is not enabled).</span>
<span class="sd">        :raises TimeoutError: If timeout set and triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Receiving object...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint has not been started, nothing to receive!&quot;</span><span class="p">)</span>

        <span class="n">p_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Multithreading detected, retrieving object &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;from buffer (size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s2">)...&quot;</span>
            <span class="p">)</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">p_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TimeoutError</span>
                    <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint has not been started!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pickled data received of size </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unmarshal_f</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span></div>


<div class="viewcode-block" id="StreamEndpoint.poll">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.poll">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Polls the state of various stats of the endpoint (see below) and addresses</span>
<span class="sd">        of endpoint.</span>
<span class="sd">            * 0,0: Existence of underlying socket (true if connected).</span>
<span class="sd">            * 0,1: Whether there is something to read on the internal buffer (async)</span>
<span class="sd">                or underlying socket (sync).</span>
<span class="sd">            * 0,2: Whether one is able to write on the internal buffer (async)</span>
<span class="sd">                or underlying socket (sync).</span>
<span class="sd">            + 1,0: Address of endpoint, else None</span>
<span class="sd">            + 1,1: Address of remote endpoint, else None.</span>
<span class="sd">        Note this does not necessarily guarantee that the underlying endpoint socket</span>
<span class="sd">        is actually connected and available for reading/writing; not only could have</span>
<span class="sd">        the connection broken down since then and is being re-established,</span>
<span class="sd">        but in multithreading mode the content of the internal buffers might change</span>
<span class="sd">        over time and thus change the read/write state.</span>

<span class="sd">        :return: Tuple of boolean states (connectivity, readability, writability) and</span>
<span class="sd">        address-pair of endpoint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">addrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
            <span class="n">states</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span><span class="o">.</span><span class="n">full</span><span class="p">()</span> <span class="ow">and</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">addrs</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_sender</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the loop to send objects over the socket retrieved from the sending</span>
<span class="sd">        buffer.</span>

<span class="sd">        Note that setting the keep-alive flag to false, terminations of the</span>
<span class="sd">        connection stops the loop, stops the endpoints (not shut down) and exits the</span>
<span class="sd">        thread automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncSender: Starting...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;AsyncSender: Starting to send objects in asynchronous mode...&quot;</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;AsyncSender: Retrieved and sending object (size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;from buffer (length: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_send_buffer</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;AsyncSender: Timeout triggered: Buffer empty. Retrying...&quot;</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncSender: Termination of connection detected!&quot;</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncSender: Stopping...&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_receiver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the loop to receive objects over the socket and store them in the</span>
<span class="sd">        receiving buffer.</span>

<span class="sd">        Note that setting the keep-alive flag to false, terminations of the</span>
<span class="sd">        connection stops the loop and exits the thread automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncReceiver: Starting...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;AsyncReceiver: Starting to receive objects in asynchronous mode...&quot;</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">p_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;AsyncReceiver: Storing received object (size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">p_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;in buffer (length: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s2">)...&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recv_buffer</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">p_obj</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;AsyncReceiver: Timeout triggered: Buffer full. &quot;</span>
                    <span class="s2">&quot;Discarding object...&quot;</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncReceiver: Termination of connection detected!&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncReceiver: Stopping...&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">receive</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown</span>
            <span class="ow">and</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender</span>
            <span class="ow">and</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receiver</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="StreamEndpoint.create_quick_sender_ep">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.create_quick_sender_ep">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_quick_sender_ep</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
        <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;QuickSenderEndpoint&quot;</span><span class="p">,</span>
        <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">send_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">marshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">object</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
        <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a (simplified) one-time endpoint to send a number of objects to a</span>
<span class="sd">        remote endpoint before shutting down. May be called non-blocking to handle</span>
<span class="sd">        endpoint in background entirely.</span>

<span class="sd">        :param objects: Iterable of objects to send to remote endpoint.</span>
<span class="sd">        :param remote_addr: Address of remote endpoint to send messages to.</span>
<span class="sd">        :param name: Name of endpoint for logging purposes.</span>
<span class="sd">        :param addr: Address of endpoint.</span>
<span class="sd">        :param send_b_size: Underlying send buffer size of socket.</span>
<span class="sd">        :param compression: Enables lz4 stream compression for bandwidth optimization.</span>
<span class="sd">        :param marshal_f: Marshal function to serialize objects to send into byte</span>
<span class="sd">        :param blocking: Whether endpoint and message handling is to be done</span>
<span class="sd">        synchronously or asynchronously (using threads).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">quick_sender_ep</span><span class="p">():</span>
            <span class="n">endpoint</span> <span class="o">=</span> <span class="n">StreamEndpoint</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span>
                <span class="n">remote_addr</span><span class="o">=</span><span class="n">remote_addr</span><span class="p">,</span>
                <span class="n">acceptor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">send_b_size</span><span class="o">=</span><span class="n">send_b_size</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
                <span class="n">marshal_f</span><span class="o">=</span><span class="n">marshal_f</span><span class="p">,</span>
                <span class="n">multithreading</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">endpoint</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="n">endpoint</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">endpoint</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span><span class="p">:</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">quick_sender_ep</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quick_sender_ep</span><span class="p">()</span></div>


<div class="viewcode-block" id="StreamEndpoint.receive_latest_ep_objs">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.receive_latest_ep_objs">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">receive_latest_ep_objs</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Self</span><span class="p">],</span> <span class="n">obj_type</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Self</span><span class="p">,</span> <span class="n">Optional</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Endpoint helper function to receive the latest objects of a certain type</span>
<span class="sd">        from a number of endpoints. Note this flushes any other messages held by</span>
<span class="sd">        these endpoints as well, as non-blocking receives are called on them until</span>
<span class="sd">        their buffers are exhausted. Any messages of others types are discarded,</span>
<span class="sd">        as are endpoints who are not ready.</span>

<span class="sd">        :param endpoints: Iterable of endpoints to receive objects from.</span>
<span class="sd">        :param obj_type: Type of objects to receive. If none given, receives the latest</span>
<span class="sd">        message of any type.</span>
<span class="sd">        :return: Dictionary of each endpoint and their respective latest received</span>
<span class="sd">        object, None if nothing received for endpoint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ep_objs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">endpoint</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="n">ep_obj</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">ep_msg</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ep_msg</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">):</span>
                        <span class="n">ep_obj</span> <span class="o">=</span> <span class="n">ep_msg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">TimeoutError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="n">ep_objs</span><span class="p">[</span><span class="n">endpoint</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep_obj</span>
        <span class="k">return</span> <span class="n">ep_objs</span></div>


<div class="viewcode-block" id="StreamEndpoint.select_eps">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.StreamEndpoint.select_eps">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_eps</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Self</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Endpoint select helper function to check a number of endpoints whether</span>
<span class="sd">        objects can be read from or written to them. For simplicity&#39;s sake, does not</span>
<span class="sd">        mirror the actual UNIX select function (supporting separate lists).</span>

<span class="sd">        :param endpoints: Iterable of endpoints to check for readiness.</span>
<span class="sd">        :return: Tuple of lists of endpoints that are read/write ready:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ep_states</span> <span class="o">=</span> <span class="p">[(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">poll</span><span class="p">())</span> <span class="k">for</span> <span class="n">endpoint</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">]</span>
        <span class="n">r_ready</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ep_states</span><span class="p">)))</span>
        <span class="n">w_ready</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">ep_states</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">r_ready</span><span class="p">,</span> <span class="n">w_ready</span></div>
</div>



<div class="viewcode-block" id="EndpointServer">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EndpointServer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper class to manage a group of (acceptor) connection endpoints listening to</span>
<span class="sd">    the same address. Supports all features of the existing endpoint class, besides</span>
<span class="sd">    also supporting thread-safe access, polling, and management of them as a group.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span>

    <span class="n">_connection_handler</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span>
    <span class="n">_connection_cleaner</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span>

    <span class="n">_connections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">]</span>
    <span class="n">_p_connections</span><span class="p">:</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">]]</span>
    <span class="n">_n_connections</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_c_timeout</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_c_lock</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span>

    <span class="n">_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">_addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">_send_b_size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_recv_b_size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_compression</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_marshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">object</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">]</span>
    <span class="n">_unmarshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">bytes</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span>
    <span class="n">_multithreading</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_buffer_size</span><span class="p">:</span> <span class="nb">int</span>

    <span class="n">_keep_alive</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="n">_started</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;EndpointServer&quot;</span><span class="p">,</span>
        <span class="n">c_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">send_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">recv_b_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">marshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">object</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
        <span class="n">unmarshal_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">bytes</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">,</span>
        <span class="n">multithreading</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
        <span class="n">keep_alive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new endpoint server.</span>

<span class="sd">        :param addr: Address of endpoint server.</span>
<span class="sd">        :param name: Name of endpoint server for logging purposes.</span>
<span class="sd">        :param c_timeout: Timeout (secs) for disconnected connection endpoints when</span>
<span class="sd">        performing periodic cleanup. Default is no cleanup.</span>
<span class="sd">        :param send_b_size: Underlying send buffer size of all connection sockets.</span>
<span class="sd">        :param recv_b_size: Underlying receive buffer size of all connection sockets.</span>
<span class="sd">        :param compression: Enables lz4 stream compression for bandwidth optimization.</span>
<span class="sd">        :param marshal_f: Marshal function to serialize objects to send into bytes.</span>
<span class="sd">        :param unmarshal_f: Unmarshal function to deserialize received bytes into</span>
<span class="sd">        objects.</span>
<span class="sd">        :param multithreading: Enables transparent multithreading (for individual</span>
<span class="sd">        endpoints) for speedup.</span>
<span class="sd">        :param buffer_size: Size of shared buffers, both for server and for</span>
<span class="sd">        connection endpoints in multithreading mode.</span>
<span class="sd">        :param keep_alive: Determines whether connection endpoints should attempt</span>
<span class="sd">        re-connects after their remote counterparts have terminated the connection.</span>
<span class="sd">        Such connection terminations will then result in RuntimeErrors in synchronous</span>
<span class="sd">        mode during send()/receive() and a more ressource efficient handling when</span>
<span class="sd">        multithreading by closing endpoints prematurely. Note that the actual</span>
<span class="sd">        shutdown and cleanup of the actual endpoint is still done by the server.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initializing endpoint server </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_connections</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_connections</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_timeout</span> <span class="o">=</span> <span class="n">c_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addr</span> <span class="o">=</span> <span class="n">addr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_send_b_size</span> <span class="o">=</span> <span class="n">send_b_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recv_b_size</span> <span class="o">=</span> <span class="n">recv_b_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compression</span> <span class="o">=</span> <span class="n">compression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_marshal_f</span> <span class="o">=</span> <span class="n">marshal_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unmarshal_f</span> <span class="o">=</span> <span class="n">unmarshal_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span> <span class="o">=</span> <span class="n">multithreading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_keep_alive</span> <span class="o">=</span> <span class="n">keep_alive</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Endpoint server </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2"> initialized.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="EndpointServer.start">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer.start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the endpoint server, launching the connection handlers in the</span>
<span class="sd">        background.</span>

<span class="sd">        :raises RuntimeError: If endpoint server has already been started.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting endpoint server...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint server has already been started!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connection_handler</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_connection_handler</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection_handler</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Connection timeout detected, starting periodic cleanup thread...&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection_cleaner</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_connections</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection_cleaner</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Endpoint server started.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EndpointServer.stop">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer.stop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stops the endpoint server along all its connection endpoints, cleaning up</span>
<span class="sd">        underlying datastructures. This always shuts down all connection endpoints</span>
<span class="sd">        with a given timeout (see stop() of the Endpoint class for more information</span>
<span class="sd">        on this behavior).</span>

<span class="sd">        :param timeout: Allows each connection endpoint to process remaining messages</span>
<span class="sd">        until timeout. This is done for each endpoint and not in parallel if blocking.</span>
<span class="sd">        :param blocking: Whether to wait for endpoints to be closed before exiting.</span>
<span class="sd">        :raises RuntimeError: If endpoint server has not been started.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Stopping endpoint server...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Endpoint server has not been started!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Waiting for connection handler threader to stop...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection_handler</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Waiting for periodic cleanup thread to stop...&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection_cleaner</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Closing connections...&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span><span class="p">:</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_conns</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">timeout</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_conns</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Endpoint server stopped.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EndpointServer.poll_connections">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer.poll_connections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">poll_connections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Polls the state of all current available connection endpoints, filtering</span>
<span class="sd">        them for readability and writability.</span>

<span class="sd">        Note that while this method is thread-safe in itself, it is not guaranteed</span>
<span class="sd">        that any returned endpoint will be still connected (and available) at the</span>
<span class="sd">        point of using it, since the underlying cleanup thread (if enabled) might</span>
<span class="sd">        have closed any potential dead endpoint if general timeout set (see __init__()).</span>

<span class="sd">        :return: Tuple of dictionary of addresses and endpoints from which can be</span>
<span class="sd">        read from / written to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Polling </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">)</span><span class="si">}</span><span class="s2"> connections &quot;</span>
                <span class="s2">&quot;for readability and writability...&quot;</span>
            <span class="p">)</span>
            <span class="n">c_states</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">:</span> <span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">.</span><span class="n">poll</span><span class="p">())</span> <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">r_ready</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">c_states</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]}</span>
        <span class="n">w_ready</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">c_states</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">r_ready</span><span class="p">)</span><span class="si">}</span><span class="s2"> connections for readability and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">w_ready</span><span class="p">)</span><span class="si">}</span><span class="s2"> connections for writability found.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">r_ready</span><span class="p">,</span> <span class="n">w_ready</span></div>


<div class="viewcode-block" id="EndpointServer.get_connections">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer.get_connections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_connections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">addrs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StreamEndpoint</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks a list of given client addresses whether there is an available</span>
<span class="sd">        connection endpoint for each of them and retrieves them.</span>

<span class="sd">        Note that while this method is thread-safe in itself, it is not guaranteed</span>
<span class="sd">        that any returned endpoint will be still connected (and available) at the</span>
<span class="sd">        point of using it, since the underlying cleanup thread (if enabled) might</span>
<span class="sd">        have closed any potential dead endpoint if general timeout set (see __init__()).</span>

<span class="sd">        :param addrs: Client addresses to check and retrieve endpoints for.</span>
<span class="sd">        :return: Dictionary of addresses and endpoints (None if not existing).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to retrieve </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">addrs</span><span class="p">)</span><span class="si">}</span><span class="s2"> connections...&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">addr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addrs</span><span class="p">}</span></div>


<div class="viewcode-block" id="EndpointServer.get_new_connections">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer.get_new_connections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_new_connections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks and retrieves the first n new connections in the underlying queue</span>
<span class="sd">        filled by the connection handler.</span>

<span class="sd">        Note that while this method is thread-safe in itself, it is not guaranteed</span>
<span class="sd">        that any returned endpoint will be still connected (and available) at the</span>
<span class="sd">        point of using it, since the underlying cleanup thread (if enabled) might</span>
<span class="sd">        have closed any potential dead endpoint if general timeout set (see __init__()).</span>

<span class="sd">        :param n: Maximum numbers of new connections to retrieve.</span>
<span class="sd">        :param timeout: Maximum time when polling for new connections.</span>
<span class="sd">        :return: Dictionary of new addresses and endpoints of new connections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to retrieve </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> new connections...&quot;</span><span class="p">)</span>
        <span class="n">new_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_connections</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">remaining_timeout</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">-</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">addr</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_connections</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">remaining_timeout</span><span class="p">)</span>
                <span class="n">new_connections</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_connections</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> new connections retrieved.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_connections</span></div>


<div class="viewcode-block" id="EndpointServer.close_connections">
<a class="viewcode-back" href="../../../daisy.communication.html#daisy.communication.message_stream.EndpointServer.close_connections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close_connections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">addrs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks a list of given client addresses whether there is an available</span>
<span class="sd">        connection endpoint for each of them and closes them, shutting them also down.</span>

<span class="sd">        :param addrs: Client addresses to check and close endpoints for.</span>
<span class="sd">        :param timeout: Timeout for shutting down connection endpoints.</span>
<span class="sd">        :param blocking: Whether to wait for endpoints to be closed before returning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Closing connections...&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addrs</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span><span class="p">:</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_conns</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">timeout</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_conns</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_connection_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the loop to create new endpoints, connect them to their remote</span>
<span class="sd">        counterparts, and store them into the underlying datastructures of the server.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncHandler: Starting connection handler...&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_connections</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">logging_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;AsyncHandler: [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_connections</span><span class="si">}</span><span class="s2">] &quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">logging_prefix</span> <span class="o">+</span> <span class="s2">&quot;Preparing endpoint for connection...&quot;</span><span class="p">)</span>
            <span class="n">new_connection</span> <span class="o">=</span> <span class="n">StreamEndpoint</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_connections</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr</span><span class="p">,</span>
                <span class="n">remote_addr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">acceptor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">send_b_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_send_b_size</span><span class="p">,</span>
                <span class="n">recv_b_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_recv_b_size</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compression</span><span class="p">,</span>
                <span class="n">marshal_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_marshal_f</span><span class="p">,</span>
                <span class="n">unmarshal_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_unmarshal_f</span><span class="p">,</span>
                <span class="n">multithreading</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_multithreading</span><span class="p">,</span>
                <span class="n">buffer_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span>
                <span class="n">keep_alive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keep_alive</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n_connection_rdy</span> <span class="o">=</span> <span class="n">new_connection</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">n_connection_rdy</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="n">logging_prefix</span> <span class="o">+</span> <span class="s2">&quot;Waiting for endpoint to establish a connection...&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">remote_addr</span> <span class="o">=</span> <span class="n">new_connection</span><span class="o">.</span><span class="n">poll</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="n">logging_prefix</span>
                        <span class="o">+</span> <span class="s2">&quot;Storing connection endpoint in pending queue...&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p_connections</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">remote_addr</span><span class="p">,</span> <span class="n">new_connection</span><span class="p">),</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">remote_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_connection</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="n">logging_prefix</span> <span class="o">+</span> <span class="s2">&quot;New connection endpoint handled.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="n">logging_prefix</span>
                        <span class="o">+</span> <span class="s2">&quot;Pending queue full. Discarding oldest endpoint...&quot;</span>
                    <span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_p_connections</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                        <span class="k">continue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncHandler: Stopping...&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cleanup_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the loop to periodically check all connection endpoints of the</span>
<span class="sd">        server for dead connections and clean up those that remain dead after a set</span>
<span class="sd">        timeout (see __init__()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncCleaner: Starting periodic connection cleanup...&quot;</span><span class="p">)</span>
        <span class="n">c_pending</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
                <span class="n">c_dead</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">addr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">c_pending</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ep</span><span class="o">.</span><span class="n">poll</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;AsyncCleaner: Closing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">c_dead</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">c_pending</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;inactive and marked connection endpoints...&quot;</span>
            <span class="p">)</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_conns</span><span class="p">(</span><span class="n">c_dead</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lock</span><span class="p">:</span>
                <span class="n">c_pending</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">addr</span><span class="p">:</span> <span class="n">ep</span>
                    <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ep</span><span class="o">.</span><span class="n">poll</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;AsyncCleaner: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">c_pending</span><span class="p">)</span><span class="si">}</span><span class="s2"> inactive connection endpoints &quot;</span>
                <span class="s2">&quot;found and marked.&quot;</span>
            <span class="p">)</span>
            <span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;AsyncCleaner: Stopping...&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_close_conns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">connections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">StreamEndpoint</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method to close and shutting down a number of endpoints.</span>

<span class="sd">        :param connections: Connection endpoints to close.</span>
<span class="sd">        :param timeout: Individual timeout for shutting down connection endpoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to close </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span><span class="si">}</span><span class="s2"> connections...&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">endpoint</span> <span class="ow">in</span> <span class="n">connections</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shutting down connection endpoint </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">endpoint</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span><span class="si">}</span><span class="s2"> connections closed.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_connections</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_started</span>
            <span class="ow">and</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_handler</span>
            <span class="ow">and</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_cleaner</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_convert_addr_to_name</span><span class="p">(</span>
    <span class="n">addr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Translates a socket address, which is either a 2-tuple (ipv4) or a 4-tuple (ipv6)</span>
<span class="sd">    into a 2-tuple (host, port). Tries to resolve the host to its (DNS)</span>
<span class="sd">    hostname, otherwise keeps the numeric representation. Ports/Services are always</span>
<span class="sd">    kept numeric.</span>

<span class="sd">    :param addr: Address (ipv4/6) to convert.</span>
<span class="sd">    :return: Address tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">socket</span><span class="o">.</span><span class="n">getnameinfo</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">NI_NUMERICSERV</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span>
        <span class="n">socket</span><span class="o">.</span><span class="n">getnameinfo</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">NI_NUMERICSERV</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>


<span class="c1"># noinspection PyTypeChecker</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_send_payload</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">payload</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a payload over a socket, performing simple marshalling (size is sent</span>
<span class="sd">    first, then the bytes of the object). Blocking (if passed socket not configured</span>
<span class="sd">    otherwise).</span>

<span class="sd">    :param sock: Sockets to send payload over</span>
<span class="sd">    :param payload: Payload to send.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">payload_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">p_payload_size</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">(</span><span class="n">payload_size</span><span class="p">))</span>
    <span class="n">_send_n_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">p_payload_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">_send_n_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">payload_size</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_send_n_data</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a number of bytes over a socket.</span>

<span class="sd">    :param sock: Sockets to send bytes over.</span>
<span class="sd">    :param data: Bytes to send.</span>
<span class="sd">    :param size: Number of bytes to send.</span>
<span class="sd">    :raises RuntimeError: If connection has been closed by remote.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sent_bytes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent_bytes</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">n_sent_bytes</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">sent_bytes</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">n_sent_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Connection terminated!&quot;</span><span class="p">)</span>
        <span class="n">sent_bytes</span> <span class="o">+=</span> <span class="n">n_sent_bytes</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_recv_payload</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Receives a payload over a socket, performing simple marshalling (size is</span>
<span class="sd">    received first, then the bytes of the object). Blocking (if passed socket not</span>
<span class="sd">    configured otherwise).</span>

<span class="sd">    :param sock: Socket to received payload over.</span>
<span class="sd">    :return: Received Payload.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p_payload_size</span> <span class="o">=</span> <span class="n">_recv_n_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">payload_size</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">p_payload_size</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recv_n_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">payload_size</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_recv_n_data</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">buff_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Receives a number of bytes over a socket.</span>

<span class="sd">    :param sock: Socket to receive bytes over.</span>
<span class="sd">    :param size: Number of bytes to receive.</span>
<span class="sd">    :param buff_size: Maximum number of bytes to receive from socket per receive</span>
<span class="sd">    iteration.</span>
<span class="sd">    :return: Received n bytes.</span>
<span class="sd">    :raises RuntimeError: If connection has been closed by remote.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">r_size</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">while</span> <span class="n">r_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">r_size</span><span class="p">,</span> <span class="n">buff_size</span><span class="p">))</span>
        <span class="n">n_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Connection terminated!&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="n">r_size</span> <span class="p">:</span> <span class="n">size</span> <span class="o">-</span> <span class="n">r_size</span> <span class="o">+</span> <span class="n">n_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_data</span>
        <span class="n">r_size</span> <span class="o">-=</span> <span class="n">n_size</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_r_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks a given socket whether data can be read from it.</span>

<span class="sd">    :param sock: Socket to check for read readiness.</span>
<span class="sd">    :param timeout: Timeout (seconds) to wait for socket to be read ready.</span>
<span class="sd">    :return: True if socket is ready to be read from, else false.</span>
<span class="sd">    :raises TimeoutError: If timeout set and triggered.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">timeout</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TimeoutError</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_w_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks a given socket whether data can be written to it.</span>

<span class="sd">    :param sock: Socket to check for write readiness.</span>
<span class="sd">    :return: True if socket is ready to be written to, else false.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_close_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Closes the socket of an endpoint, shutdowns any potential connection that</span>
<span class="sd">    might have been established.</span>

<span class="sd">    :param sock: Socket to close.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Fabian Hofmann, Seraphin Zunzer, Jonathan Ackerschewski, Lotta Fejzula.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>